<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbital Mechanics Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import Map for Three.js -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <style type="text/css">
      body { margin: 0; overflow: hidden; background-color: #0f172a; color: #e2e8f0; font-family: monospace; }
      canvas { display: block; }
      
      /* Custom Scrollbar for controls */
      ::-webkit-scrollbar { width: 8px; }
      ::-webkit-scrollbar-track { background: #1e293b; }
      ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
      ::-webkit-scrollbar-thumb:hover { background: #64748b; }
      
      .slider-label { display: flex; justify-content: space-between; font-size: 0.75rem; margin-bottom: 0.25rem; }
      .slider-input { width: 100%; accent-color: #38bdf8; cursor: pointer; }
      .input-group { margin-bottom: 1rem; }
      .tab-active { border-bottom: 2px solid #38bdf8; color: #38bdf8; }
      .tab-inactive { color: #94a3b8; }
      .panel { background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(4px); border: 1px solid #334155; }
    </style>
  </head>
  <body>
    
    <!-- Main 3D Container -->
    <div id="canvas-container" class="absolute inset-0 z-0"></div>
    
    <!-- UI Overlay -->
    <div class="absolute top-4 right-4 w-80 flex flex-col gap-4 max-h-[95vh] overflow-y-auto z-10">
      
      <!-- Panel 1: Orbital Elements -->
      <div class="panel p-4 rounded-lg shadow-lg">
        <h2 class="text-lg font-bold text-sky-400 mb-3 border-b border-slate-700 pb-2">Initial Orbit Elements</h2>
        
        <div class="input-group">
          <div class="slider-label"><span>Central Body (&mu;)</span><span id="val-mu"></span></div>
          <input type="range" id="in-mu" min="100" max="10000" value="3986" class="slider-input">
        </div>
        
        <div class="input-group">
          <div class="slider-label"><span>Semimajor Axis (a)</span><span id="val-a"></span></div>
          <input type="range" id="in-a" min="5" max="50" step="0.1" value="15" class="slider-input">
        </div>
        
        <div class="input-group">
          <div class="slider-label"><span>Eccentricity (e)</span><span id="val-e"></span></div>
          <input type="range" id="in-e" min="0" max="0.9" step="0.01" value="0.3" class="slider-input">
        </div>
        
        <div class="input-group">
          <div class="slider-label"><span>Inclination (i) [deg]</span><span id="val-i"></span></div>
          <input type="range" id="in-i" min="0" max="180" step="1" value="15" class="slider-input">
        </div>
        
        <div class="input-group">
          <div class="slider-label"><span>RAAN (&Omega;) [deg]</span><span id="val-raan"></span></div>
          <input type="range" id="in-raan" min="0" max="360" step="1" value="45" class="slider-input">
        </div>
        
        <div class="input-group">
          <div class="slider-label"><span>Arg. Periapsis (&omega;) [deg]</span><span id="val-w"></span></div>
          <input type="range" id="in-w" min="0" max="360" step="1" value="0" class="slider-input">
        </div>
        
        <div class="input-group">
          <div class="slider-label"><span>True Anomaly (&nu;) [deg]</span><span id="val-nu"></span></div>
          <input type="range" id="in-nu" min="0" max="360" step="1" value="90" class="slider-input">
        </div>
      </div>
      
      <!-- Panel 2: State Vector Readout -->
      <div class="panel p-4 rounded-lg shadow-lg text-xs font-mono">
        <h2 class="text-lg font-bold text-emerald-400 mb-3 border-b border-slate-700 pb-2">Current State</h2>
        <div class="grid grid-cols-2 gap-2">
          <div>
            <div class="text-slate-400">Position (r)</div>
            <div id="out-r" class="text-white"></div>
            <div id="out-rmag" class="text-emerald-500 mt-1"></div>
          </div>
          <div>
            <div class="text-slate-400">Velocity (v)</div>
            <div id="out-v" class="text-white"></div>
            <div id="out-vmag" class="text-emerald-500 mt-1"></div>
          </div>
        </div>
      </div>
      
      <!-- Panel 3: Delta V Controls -->
      <div class="panel p-4 rounded-lg shadow-lg">
        <h2 class="text-lg font-bold text-rose-400 mb-3 border-b border-slate-700 pb-2">Maneuver (&Delta;V)</h2>
        
        <!-- Tabs -->
        <div class="flex mb-4 border-b border-slate-700">
          <button id="tab-btn-1" class="flex-1 py-2 text-sm font-bold tab-active" onclick="switchTab(1)">Velocity Frame</button>
          <button id="tab-btn-2" class="flex-1 py-2 text-sm font-bold tab-inactive" onclick="switchTab(2)">Local Horizon</button>
        </div>
        
        <!-- Tab 1 Content: Velocity Relative (TNB) -->
        <div id="tab-content-1">
          <div class="input-group">
            <div class="slider-label"><span class="text-rose-300">Prograde (Tangent)</span><span id="val-dv-pro"></span></div>
            <input type="range" id="in-dv-pro" min="-5" max="5" step="0.1" value="0" class="slider-input">
          </div>
          <div class="input-group">
            <div class="slider-label"><span class="text-rose-300">Normal (In-Plane)</span><span id="val-dv-norm"></span></div>
            <input type="range" id="in-dv-norm" min="-5" max="5" step="0.1" value="0" class="slider-input">
          </div>
          <div class="input-group">
            <div class="slider-label"><span class="text-rose-300">Binormal (Out-Plane)</span><span id="val-dv-bi"></span></div>
            <input type="range" id="in-dv-bi" min="-5" max="5" step="0.1" value="0" class="slider-input">
          </div>
        </div>
        
        <!-- Tab 2 Content: Local Horizon (RSW) -->
        <div id="tab-content-2" class="hidden">
          <div class="input-group">
            <div class="slider-label"><span class="text-amber-300">Vertical (Radial)</span><span id="val-dv-rad"></span></div>
            <input type="range" id="in-dv-rad" min="-5" max="5" step="0.1" value="0" class="slider-input">
          </div>
          <div class="input-group">
            <div class="slider-label"><span class="text-amber-300">Horiz. (In-Plane)</span><span id="val-dv-hor"></span></div>
            <input type="range" id="in-dv-hor" min="-5" max="5" step="0.1" value="0" class="slider-input">
          </div>
          <div class="input-group">
            <div class="slider-label"><span class="text-amber-300">Horiz. (Out-Plane)</span><span id="val-dv-oop"></span></div>
            <input type="range" id="in-dv-oop" min="-5" max="5" step="0.1" value="0" class="slider-input">
          </div>
        </div>
        
        <div class="text-xs text-slate-500 mt-2 italic text-center">
          Resulting Orbit shown in Red
        </div>
      </div>
      
    </div>
    
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      
      // --- Configuration & State ---
      const config = {
        mu: 3986,
        a: 15,
        e: 0.3,
        i: 15,
        raan: 45,
        w: 0,
        nu: 90,
        // Delta V components
        dv_pro: 0, dv_norm: 0, dv_bi: 0, // Tab 1
        dv_rad: 0, dv_hor: 0, dv_oop: 0, // Tab 2
      };
      
      // --- Scene Setup ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(25, 20, 25);
      camera.up.set(0, 1, 0); // Y is Up
      
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('canvas-container').appendChild(renderer.domElement);
      
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      
      // --- Objects ---
      
      // 1. Central Body
      const geometryPlanet = new THREE.SphereGeometry(2, 32, 32);
      const materialPlanet = new THREE.MeshBasicMaterial({ color: 0x38bdf8, wireframe: true, transparent: true, opacity: 0.3 });
      const planet = new THREE.Mesh(geometryPlanet, materialPlanet);
      // Add a solid core
      const core = new THREE.Mesh(new THREE.SphereGeometry(1.95, 32, 32), new THREE.MeshBasicMaterial({ color: 0x0f172a }));
      planet.add(core);
      scene.add(planet);
      
      // 2. Reference Grid (Ecliptic Plane X-Z)
      const gridHelper = new THREE.GridHelper(100, 50, 0x334155, 0x1e293b);
      scene.add(gridHelper);
      const axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);
      
      // 3. Spacecraft
      const shipGeo = new THREE.ConeGeometry(0.4, 1, 16);
      shipGeo.rotateX(Math.PI / 2); // Point along Z initially
      const shipMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const spacecraft = new THREE.Mesh(shipGeo, shipMat);
      scene.add(spacecraft);
      
      // 4. Orbit Lines
      const orbit1Mat = new THREE.LineBasicMaterial({ color: 0x38bdf8 }); // Blue
      const orbit2Mat = new THREE.LineBasicMaterial({ color: 0xf43f5e, dashSize: 1, gapSize: 0.5 }); // Red
      
      const orbit1Line = new THREE.LineLoop(new THREE.BufferGeometry(), orbit1Mat);
      scene.add(orbit1Line);
      
      const orbit2Line = new THREE.Line(new THREE.BufferGeometry(), orbit2Mat);
      scene.add(orbit2Line);
      
      // --- Math Helpers ---
      
      const D2R = Math.PI / 180.0;
      const R2D = 180.0 / Math.PI;
      
      class Vector3 {
        constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
        add(v) { return new Vector3(this.x + v.x, this.y + v.y, this.z + v.z); }
        sub(v) { return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z); }
        scale(s) { return new Vector3(this.x * s, this.y * s, this.z * s); }
        mag() { return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z); }
        dot(v) { return this.x*v.x + this.y*v.y + this.z*v.z; }
        cross(v) {
          return new Vector3(
            this.y * v.z - this.z * v.y,
            this.z * v.x - this.x * v.z,
            this.x * v.y - this.y * v.x
          );
        }
        normalize() {
          const m = this.mag();
          if (m === 0) return new Vector3(0,0,0);
          return new Vector3(this.x/m, this.y/m, this.z/m);
        }
      }
      
      /**
       * Calculates position and velocity from Keplerian elements.
       * Coordinate conversion: Standard Physics (Z-up) -> Three.js (Y-up).
       * Three.js Y is Orbital Z (Normal to Ref Plane).
       * Three.js X is Orbital X (Vernal Equinox).
       * Three.js Z is Orbital Y.
       */
      function getStateFromElements(mu, a, e, i_deg, raan_deg, w_deg, nu_deg) {
        const i = i_deg * D2R;
        const raan = raan_deg * D2R;
        const w = w_deg * D2R;
        const nu = nu_deg * D2R;
        
        const p = a * (1 - e * e);
        const r_mag = p / (1 + e * Math.cos(nu));
        
        // Position in Perifocal frame (PQW)
        // P points to periapsis, Q is 90 deg in plane, W is normal
        const r_pqw = new Vector3(
          r_mag * Math.cos(nu),
          r_mag * Math.sin(nu),
          0
        );
        
        // Velocity in Perifocal frame
        // v = sqrt(mu/p) * [-sin(nu), e + cos(nu), 0]
        const v_fac = Math.sqrt(mu / p);
        const v_pqw = new Vector3(
          -Math.sin(nu),
          e + Math.cos(nu),
          0
        ).scale(v_fac);
        
        // Rotation Matrices (3-1-3 Sequence: Rz(-O) -> Rx(-i) -> Rz(-w) INVERSE)
        // Actually, simpler to just apply rotations manually.
        // 1. Rotate by -w around Z (Argument of Periapsis)
        // 2. Rotate by -i around X (Inclination)
        // 3. Rotate by -raan around Z (RAAN)
        
        // Helper to rotate a vector around Z axis
        const rotZ = (v, angle) => {
          const c = Math.cos(angle); const s = Math.sin(angle);
          return new Vector3(v.x*c - v.y*s, v.x*s + v.y*c, v.z);
        };
        // Helper to rotate around X axis
        const rotX = (v, angle) => {
          const c = Math.cos(angle); const s = Math.sin(angle);
          return new Vector3(v.x, v.y*c - v.z*s, v.y*s + v.z*c);
        };
        
        // Apply rotations to r
        let r = rotZ(r_pqw, w);
        r = rotX(r, i);
        r = rotZ(r, raan);
        
        // Apply rotations to v
        let v = rotZ(v_pqw, w);
        v = rotX(v, i);
        v = rotZ(v, raan);
        
        // Swap coordinates for Three.js (Y-up)
        // Physics: X, Y, Z(up)
        // Three:   X, Z, -Y(up)?? No, simpler mapping:
        // Physics X -> Three X
        // Physics Y -> Three -Z
        // Physics Z -> Three Y
        
        const toThree = (vec) => new Vector3(vec.x, vec.z, -vec.y);
        
        return {
          r: toThree(r),
          v: toThree(v)
        };
      }
      
      /**
       * Solves Cartesian State -> Orbital Elements
       * Needed to draw the trajectory of Orbit 2
       */
      function getElementsFromState(mu, r, v) {
        // Convert back to Physics Frame
        // Three X -> Physics X
        // Three Y -> Physics Z
        // Three Z -> Physics -Y
        const r_phy = new Vector3(r.x, -r.z, r.y);
        const v_phy = new Vector3(v.x, -v.z, v.y);
        
        const r_mag = r_phy.mag();
        const v_mag = v_phy.mag();
        
        // Angular Momentum h = r x v
        const h = r_phy.cross(v_phy);
        const h_mag = h.mag();
        
        // Node Vector n = k x h (where k is 0,0,1)
        const n = new Vector3(-h.y, h.x, 0);
        const n_mag = n.mag();
        
        // Eccentricity Vector
        // e = (1/mu) * [ (v^2 - mu/r)r - (r.v)v ]
        const term1 = r_phy.scale(v_mag*v_mag - mu/r_mag);
        const term2 = v_phy.scale(r_phy.dot(v_phy));
        const e_vec = term1.sub(term2).scale(1/mu);
        const e = e_vec.mag();
        
        // Mechanical Energy
        const E = (v_mag*v_mag)/2 - mu/r_mag;
        
        // Semi-major axis
        // if E is close to 0, it's parabolic. Handle ellipses/hyperbolas.
        let a = -mu / (2 * E);
        
        // Inclination
        // cos i = h_z / h
        const i = Math.acos(h.z / h_mag) * R2D;
        
        // RAAN
        // cos O = n_x / n
        let raan = 0;
        if (n_mag > 1e-6) {
          raan = Math.acos(n.x / n_mag) * R2D;
          if (n.y < 0) raan = 360 - raan;
        }
        
        // Arg of Periapsis
        // cos w = n . e / (n * e)
        let w = 0;
        if (n_mag > 1e-6 && e > 1e-6) {
          w = Math.acos(n.dot(e_vec) / (n_mag * e)) * R2D;
          if (e_vec.z < 0) w = 360 - w;
        } else if (n_mag <= 1e-6 && e > 1e-6) {
          // Equatorial orbit, w is relative to x-axis?
          // Simplification for viz: calculate angle of e_vec in xy plane
        }
        
        // True Anomaly
        // cos nu = e . r / (e * r)
        let nu = 0;
        if (e > 1e-6) {
          const val = e_vec.dot(r_phy) / (e * r_mag);
          // clamp for float errors
          nu = Math.acos(Math.max(-1, Math.min(1, val))) * R2D;
          if (r_phy.dot(v_phy) < 0) nu = 360 - nu;
        }
        
        return { a, e, i, raan, w, nu };
      }
      
      // --- Calculation & Update Loop ---
      
      function updateVisualization() {
        const mu = parseFloat(document.getElementById('in-mu').value);
        const a = parseFloat(document.getElementById('in-a').value);
        const e = parseFloat(document.getElementById('in-e').value);
        const i = parseFloat(document.getElementById('in-i').value);
        const raan = parseFloat(document.getElementById('in-raan').value);
        const w = parseFloat(document.getElementById('in-w').value);
        const nu = parseFloat(document.getElementById('in-nu').value);
        
        // 1. Calculate Initial Orbit State
        const state1 = getStateFromElements(mu, a, e, i, raan, w, nu);
        
        // Update Spacecraft Position
        spacecraft.position.set(state1.r.x, state1.r.y, state1.r.z);
        
        // Rotate Spacecraft to face velocity
        const target = state1.r.add(state1.v);
        spacecraft.lookAt(target.x, target.y, target.z);
        
        // Draw Orbit 1 (Blue)
        generateOrbitPoints(orbit1Line, mu, a, e, i, raan, w);
        
        // 2. Calculate Delta V
        // Basis Vectors for Tab 1 (Velocity Frame / NTW)
        const V_unit = state1.v.normalize();
        const R_unit = state1.r.normalize();
        const H_unit = state1.r.cross(state1.v).normalize(); // Binormal
        
        // "Normal" in NTW is usually Binormal x Tangent (pointing in plane towards center of curvature for circle)
        // Wait, prompt says "Normal (in-plane)".
        // If H is out-of-plane, V is tangent.
        // In-plane Normal = H x V.
        const N_in_plane = H_unit.cross(V_unit).normalize();
        
        // Basis Vectors for Tab 2 (Local Horizon / RSW)
        const Rad_unit = R_unit; // Radial
        const OOP_unit = H_unit; // Out of Plane (same as binormal)
        const Hor_unit = OOP_unit.cross(Rad_unit).normalize(); // Horizontal In-Plane
        
        // Get Inputs
        const dV_pro = parseFloat(document.getElementById('in-dv-pro').value);
        const dV_norm = parseFloat(document.getElementById('in-dv-norm').value);
        const dV_bi = parseFloat(document.getElementById('in-dv-bi').value);
        
        const dV_rad = parseFloat(document.getElementById('in-dv-rad').value);
        const dV_hor = parseFloat(document.getElementById('in-dv-hor').value);
        const dV_oop = parseFloat(document.getElementById('in-dv-oop').value);
        
        // Sum Delta Vs
        const deltaV = new Vector3(0,0,0);
        
        // Tab 1 contributions
        deltaV.x += V_unit.x * dV_pro + N_in_plane.x * dV_norm + H_unit.x * dV_bi;
        deltaV.y += V_unit.y * dV_pro + N_in_plane.y * dV_norm + H_unit.y * dV_bi;
        deltaV.z += V_unit.z * dV_pro + N_in_plane.z * dV_norm + H_unit.z * dV_bi;
        
        // Tab 2 contributions
        deltaV.x += Rad_unit.x * dV_rad + Hor_unit.x * dV_hor + OOP_unit.x * dV_oop;
        deltaV.y += Rad_unit.y * dV_rad + Hor_unit.y * dV_hor + OOP_unit.y * dV_oop;
        deltaV.z += Rad_unit.z * dV_rad + Hor_unit.z * dV_hor + OOP_unit.z * dV_oop;
        
        // 3. Calculate Orbit 2 State
        const v2 = state1.v.add(deltaV);
        
        // Draw Orbit 2 (Red)
        // Get elements for Orbit 2
        const els2 = getElementsFromState(mu, state1.r, v2);
        if (els2.a > 0 && els2.e < 1.0) {
          // Elliptical
          generateOrbitPoints(orbit2Line, mu, els2.a, els2.e, els2.i, els2.raan, els2.w);
          orbit2Line.visible = true;
        } else {
          // Hyperbolic/Parabolic - Draw a segment or hide for simplicity in this demo
          // For robustness, we hide if strictly hyperbolic to avoid infinite loop drawing
          // Ideally we'd draw the hyperbolic curve, but points generation differs.
          orbit2Line.visible = false; 
        }
        
        // 4. Update Readouts
        updateLabels(state1.r, state1.v);
      }
      
      function generateOrbitPoints(lineObj, mu, a, e, i, raan, w) {
        const points = [];
        const segments = 100;
        for (let j = 0; j <= segments; j++) {
          const nu = (j / segments) * 360;
          const state = getStateFromElements(mu, a, e, i, raan, w, nu);
          points.push(new THREE.Vector3(state.r.x, state.r.y, state.r.z));
        }
        lineObj.geometry.setFromPoints(points);
      }
      
      function updateLabels(r, v) {
        // Update Value Labels next to sliders
        const ids = ['mu', 'a', 'e', 'i', 'raan', 'w', 'nu', 'dv-pro', 'dv-norm', 'dv-bi', 'dv-rad', 'dv-hor', 'dv-oop'];
        ids.forEach(id => {
          const el = document.getElementById(`in-${id}`);
          const disp = document.getElementById(`val-${id}`);
          if(el && disp) disp.textContent = el.value;
        });
        
        // State Vector
        document.getElementById('out-r').textContent = `[${r.x.toFixed(2)}, ${r.y.toFixed(2)}, ${r.z.toFixed(2)}]`;
        document.getElementById('out-rmag').textContent = `|r|: ${r.mag().toFixed(2)}`;
        document.getElementById('out-v').textContent = `[${v.x.toFixed(2)}, ${v.y.toFixed(2)}, ${v.z.toFixed(2)}]`;
        document.getElementById('out-vmag').textContent = `|v|: ${v.mag().toFixed(2)}`;
      }
      
      // --- Input Event Listeners ---
      document.querySelectorAll('input[type="range"]').forEach(input => {
        input.addEventListener('input', updateVisualization);
      });
      
      // Tab Switching Logic
      window.switchTab = function(tabId) {
        if (tabId === 1) {
          document.getElementById('tab-content-1').classList.remove('hidden');
          document.getElementById('tab-content-2').classList.add('hidden');
          document.getElementById('tab-btn-1').className = "flex-1 py-2 text-sm font-bold tab-active";
          document.getElementById('tab-btn-2').className = "flex-1 py-2 text-sm font-bold tab-inactive";
        } else {
          document.getElementById('tab-content-1').classList.add('hidden');
          document.getElementById('tab-content-2').classList.remove('hidden');
          document.getElementById('tab-btn-1').className = "flex-1 py-2 text-sm font-bold tab-inactive";
          document.getElementById('tab-btn-2').className = "flex-1 py-2 text-sm font-bold tab-active";
        }
      }
      
      // --- Loop ---
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      
      // Init
      updateVisualization();
      animate();
      
      // Handle Resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
    </script>
  </body>
</html>
